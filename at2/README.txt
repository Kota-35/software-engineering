Hit & Blow ゲームアプリケーション
=====================================

## プロジェクト概要

本アプリケーションは、CUI（Character User Interface）で動作するHit & Blowゲームです。
ユーザーは4桁の数字を入力し、正解を推測します。各入力に対してHit（位置と数字が一致）と
Blow（数字は含まれるが位置が違う）の数を表示し、4Hitでゲームクリアとなります。

---

## 1. 仕様の実装状況（50%）

### 基本仕様の実装

#### ゲームルール
- ✓ 正解とユーザ入力は4桁の数字（0-9、重複なし）
- ✓ Hit: 同じ位置に同じ数字がある
- ✓ Blow: 数字は含まれるが位置が違う
- ✓ 4Hitでゲーム終了
- ✓ 10回入力しても4Hitにならない場合も終了

#### ファイル操作
- ✓ Seikai.txtから正解を読み込む（プロジェクト直下）
- ✓ 行ごとに順番にゲームを実施
- ✓ 重複する正解があってもそのまま処理

#### 入出力
- ✓ 標準入力からユーザー入力を受け取る
- ✓ 標準出力に「入力 Hit:数 Blow:数」形式で結果を表示
- ✓ Kekka.txtに全ゲームの履歴を出力（プロジェクト直下）

#### 入力検証
- ✓ 4桁、0-9の数字、重複なしの条件を満たさない入力は再入力を求める
- ✓ 不正入力は履歴に含めない

#### 結果出力
- ✓ ゲームごとに「ゲームm回目」を出力
- ✓ 最大10回分の入力結果を出力
- ✓ Hit率とBlow率を計算して出力（小数点以下切り捨て）

---

## 2. 例外処理の実装（10%）

### 入力検証による例外防止

#### 不正な入力への対応
- **状況**: 4桁でない、数字以外の文字が含まれる、数字が重複している
- **処理**: エラーメッセージを表示し、有効な入力が得られるまで再入力を求める
- **実装箇所**: `InputValidator.isValid()`, `GameManager.getValidInput()`
- **エラーメッセージ例**:
  - "4桁の数字を入力してください。"
  - "0-9の数字のみを入力してください。"
  - "数字が重複しています。4つの異なる数字を入力してください。"

#### ファイル操作のエラー処理
- **状況**: Seikai.txtが存在しない、読み込みエラーが発生した場合
- **処理**: IOExceptionをキャッチし、エラーメッセージを表示してプログラムを終了
- **実装箇所**: `GameManager.run()`, `SeikaiReader.readAnswers()`

#### ファイル書き込みエラー
- **状況**: Kekka.txtへの書き込みに失敗した場合
- **処理**: IOExceptionをキャッチし、エラーメッセージを表示
- **実装箇所**: `ResultWriter.write()`, `GameManager.run()`

#### 標準入力の終了処理
- **状況**: EOF（End of File）が検出された場合
- **処理**: IOExceptionをスローし、適切なエラーメッセージを表示
- **実装箇所**: `GameManager.getValidInput()`

---

## 3. ユーザビリティへの配慮（10%）

### 明確なエラーメッセージ
- 不正入力に対して、具体的な問題点を指摘するメッセージを表示
- 例: 「数字が重複しています」→ 何が問題かを明確に伝える

### 即座のフィードバック
- 各入力に対して即座にHit/Blowの結果を表示
- ユーザーは自分の推測がどの程度正解に近いかをすぐに確認できる

### 入力の再試行機能
- 不正入力でもプログラムが終了せず、再入力を促す
- ユーザーは安心して入力できる

### ファイル読み込みエラー時の案内
- Seikai.txtが読み込めない場合、「Seikai.txtを確認してください」という
  具体的な指示を表示

---

## 4. ソースコードの読みやすさ（10%）

### クラス構造と役割分担

#### ドメインモデル（domainパッケージ）
- **Answer**: 正解を表す値オブジェクト
- **Guess**: ユーザーの推測を表す値オブジェクト
- **GameResult**: 1回の入力に対する結果（Hit数、Blow数）
- **GameHistory**: 1ゲームの履歴と統計情報（Hit率、Blow率）

#### サービス層（serviceパッケージ）
- **InputValidator**: ユーザー入力の検証ロジック
- **HitBlowCalculator**: HitとBlowの計算ロジック

#### インフラストラクチャ層（infrastructureパッケージ）
- **SeikaiReader**: Seikai.txtからの正解読み込み
- **ResultWriter**: Kekka.txtへの結果書き込み

#### アプリケーション層
- **GameManager**: ゲーム全体の流れを管理
- **ApplicationTask2**: エントリーポイント（mainメソッドのみ）

### 役割に沿ったフィールド/メソッド

各クラスは単一責任の原則に従い、明確な役割を持っています：
- ドメインモデルはデータとその操作のみを担当
- サービス層はビジネスロジックを担当
- インフラ層は外部リソース（ファイル、標準入出力）とのやり取りを担当
- GameManagerは全体の制御フローを担当

### コメントの適切さ

- 各クラスにクラスレベルのJavaDocコメントを付与
- 各publicメソッドにJavaDocコメントを付与（パラメータ、戻り値、説明）
- 複雑なロジックにはインラインコメントを付与
- メソッド名と変数名が明確で、コメントが補足的な役割を果たしている

---

## 5. 仕様外でも魅力的な機能/特徴（25%）

### 1. レイヤードアーキテクチャの採用

**特徴**: ドメイン、サービス、インフラストラクチャの3層に明確に分離

**魅力**:
- 各レイヤーの責務が明確で、保守性が高い
- テストが容易（各レイヤーを独立してテスト可能）
- 将来的な拡張（例: GUIへの変更、データベースへの移行）が容易

**実装**:
- domainパッケージ: ビジネスロジックの中核となる値オブジェクト
- serviceパッケージ: 再利用可能なビジネスロジック
- infrastructureパッケージ: 外部リソースとのやり取り

### 2. 値オブジェクトパターンの採用

**特徴**: Answer、Guess、GameResult、GameHistoryを不変オブジェクトとして実装

**魅力**:
- データの整合性が保証される（一度作成されたオブジェクトは変更不可）
- バグの発生を防ぐ（意図しない変更が不可能）
- スレッドセーフ（複数のスレッドから安全にアクセス可能）

**実装**: すべてのフィールドをfinalで宣言し、setterメソッドを提供しない

### 3. 計算ロジックの分離

**特徴**: Hit/Blowの計算をHitBlowCalculatorクラスに分離

**魅力**:
- 計算ロジックが独立しており、テストが容易
- 将来的に計算アルゴリズムを変更する場合、1つのクラスだけを修正すればよい
- 計算ロジックの再利用が可能

### 4. 入力検証の分離と拡張性

**特徴**: InputValidatorクラスで入力検証ロジックを分離

**魅力**:
- 検証ルールの変更が容易（1つのクラスだけを修正）
- エラーメッセージのカスタマイズが容易
- 将来的に検証ルールを追加する場合も拡張しやすい

**実装**: isValid()メソッドで検証、getErrorMessage()メソッドで適切なエラーメッセージを返す

### 5. 統計情報の自動計算

**特徴**: GameHistoryクラスでHit率とBlow率を自動計算

**魅力**:
- 計算ロジックがカプセル化され、呼び出し側がシンプル
- 計算方法の変更が容易（GameHistoryクラス内のみ修正）
- 将来的に他の統計情報（例: 平均試行回数）を追加する場合も拡張しやすい

**実装**: calculateHitRate()とcalculateBlowRate()メソッドで、小数点以下切り捨ての計算を実装

### 6. ファイルパスの柔軟な管理

**特徴**: SeikaiReaderとResultWriterでファイルパスを相対パスで管理

**魅力**:
- 実行時のカレントディレクトリに依存するため、プロジェクトの場所が変わっても動作する
- 将来的に設定ファイルから読み込むように変更する場合も、getFilePath()メソッドだけを修正すればよい

### 7. 拡張しやすい設計

**特徴**: インターフェースではなく具象クラスを使用しているが、各クラスの責務が明確

**魅力**:
- 将来的にインターフェースを導入する場合も、各クラスの変更が最小限
- 新しい機能（例: 難易度設定、ヒント機能）を追加する場合も、既存コードへの影響が少ない

### 8. エラーハンドリングの統一

**特徴**: IOExceptionを適切にキャッチし、ユーザーフレンドリーなメッセージを表示

**魅力**:
- プログラムが異常終了せず、ユーザーに問題を伝える
- デバッグ時にスタックトレースも出力するため、開発者にも有用

---

## クラス構成図

```
ApplicationTask2 (エントリーポイント)
    └── GameManager (ゲーム全体の管理)
        ├── SeikaiReader (正解読み込み)
        ├── InputValidator (入力検証)
        ├── HitBlowCalculator (Hit/Blow計算)
        └── ResultWriter (結果出力)
            └── GameHistory (ゲーム履歴)
                ├── GameResult (1回の結果)
                │   ├── Guess (推測)
                │   └── Answer (正解)
                └── 統計計算メソッド
```

---

## 実行方法

1. Seikai.txtをプロジェクト直下（srcと同階層）に配置
2. プロジェクトをコンパイル: `mvn compile`
3. 実行: `mvn exec:java -Dexec.mainClass="at2.ApplicationTask2"`
4. 標準入力から4桁の数字を入力
5. ゲーム終了後、Kekka.txtがプロジェクト直下に生成される

---

## ファイル構成

```
at2/
├── pom.xml
├── Seikai.txt (入力ファイル)
├── Kekka.txt (出力ファイル、実行後に生成)
├── README.txt (本ファイル)
└── src/main/java/at2/
    ├── ApplicationTask2.java
    ├── GameManager.java
    ├── domain/
    │   ├── Answer.java
    │   ├── Guess.java
    │   ├── GameResult.java
    │   └── GameHistory.java
    ├── service/
    │   ├── InputValidator.java
    │   └── HitBlowCalculator.java
    └── infrastructure/
        ├── SeikaiReader.java
        └── ResultWriter.java
```

